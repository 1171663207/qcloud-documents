## 初始化参数
初始化 SDK 的 Config 支持以下参数：
<table>
<thead><tr><th>参数</th><th>说明</th><th width=200px>类型</th><th>是否必传</th></tr></thead>
<tbody>
<tr>
<td>module</td>
<td>模块配置</td>
<td><pre style="color:white">
type ModuleConfig = {
  beautify: boolean // 默认为true
  segmentation: boolean // 默认为false
}
</pre></td>
<td>否，默认为{beautify: true, segmentation: false}</td></tr>
<tr>
<td>auth</td>
<td>鉴权参数</td>
<td><pre style="color:white;margin:0;">
type AuthConfig = {
  licenseKey: string // 控制台 <a href="https://console.cloud.tencent.com/vcube/web"><strong> Web License 管理</strong></a> 获取
  appId: string // 控制台 <a href="https://console.cloud.tencent.com/developer"><strong>账号信息</strong></a> &gt; <strong>基本信息</strong> 查看 APPID
  authFunc:() => Promise<{
    signature:string,
    timestamp:string
  }> // 请参见 <a href="https://cloud.tencent.com/document/product/616/71370">License 配置使用</a>
}
</pre></td>
<td>是</td></tr><tr>

<td>input</td>
<td>输入源</td>
<td>MediaStream|HTMLImageElement|String</td>
<td>否</td></tr>
<tr>
<td>camera</td>
<td>内置相机</td>
<td><pre style="color:white;margin:0">
type CameraConfig = {
	width: number, // 拍摄画面宽度
	height: number, // 拍摄画面高度
	mirror: boolean, // 是否开启左右镜像
    frameRate: number // 画面采集帧率
}
</pre></td>
<td>否</td></tr><tr>
<td>beautify</td>
<td>美颜参数</td>
<td><pre style="color:white;margin:0">
type BeautifyOptions = {
	whiten?: number, // 美白 0-1
	dermabrasion?: number // 磨皮0-1
	lift?: number // 瘦脸0-1
	shave?: number // 削脸0-1
	eye?: number // 大眼0-1
	chin?: number // 下巴0-1
}
</pre></td>
<td>否</td></tr>
<tr>
<td>background</td>
<td>背景参数</td>
<td><pre style="color:white">
type BackgroundOptions = {
	type: 'image' | 'blur' | 'transparent', 
	src?: string
}
</pre></td>
<td>否</td>
</tr>
<tr>
<td>loading</td>
<td>内置 loading icon 配置</td>
<td><pre style="color:white;margin:0">
type loadingConfig = {
	enable: boolean,
	size?: number
	lineWidth?: number
	strokeColor?: number
}
</pre></td>
<td>否</td>
</tr>
<tr>
<td>lazyInit</td>
<td>是否延迟初始化</td>
<td><pre style="color:white;margin:0">
boolean
</pre></td>
<td>否</td>
</tr>
</tbody>
</table>

## 回调事件
```javascript
let effectList = [];
let filterList = [];
// sdk 的回调用法
sdk.on('created', () => {
	// 在 created 回调中拉取特效和滤镜列表供页面展示
	sdk.getEffectList({
        Type: 'Preset',
        Label: '美妆',
	}).then(res => {
		effectList = res
	});
	sdk.getCommonFilter().then(res => {
		filterList = res
	})
})
sdk.on('cameraReady', async () => {
	// 在 cameraReady 回调中可以更早地获取输出画面，此时初始化传入的美颜参数还未生效
	// 适用于需要尽早地展示画面，但不要求画面一展示就有美颜的场景
	// 后续美颜生效后无需更新stream，SDK内部已处理
	const arStream = await ar.getOutput();
	// 本地播放
	// localVideo.srcObject = arStream

})
sdk.on('ready', () => {
	// 在 ready 回调中获取输出画面，此时初始化传入的美颜参数已生效
	// 区别上述cameraReady中获取output，适用于画面一展示就要有美颜的场景，但不要求尽早地展示画面
	// 根据自身业务需求选择一种处理方式即可
	const arStream = await ar.getOutput();
	// 本地播放
	// localVideo.srcObject = arStream

	// 在 ready 回调中调用 setBeautify/setEffect/setFilter 等渲染方法
	sdk.setBeautify({
		whiten: 0.3
	});
	sdk.setEffect({
		id: effectList[0].EffectId,
		intensity: 0.7
	});
	sdk.setEffect({
		id: effectList[0].EffectId,
		intensity: 0.7,
		filterIntensity: 0.5 // 0.1.18及以上版本支持单独设置effect中滤镜的强度，不传则默认与特效的intensity保持一致
	});
	sdk.setFilter(filterList[0].EffectId, 0.5)
})

```

| 事件  | 说明                            | 回调参数  |
| ----- |-------------------------------| --------- |
| created | SDK 鉴权完成并成功创建实例时触发            | -         |
| cameraReady | SDK 的画面生成时触发，此时 output 已有画面但美颜仍无法生效 | -         |
| ready | SDK 内部检测初始化完成时触发，此时 output 画面已有美颜，也可以设置新的特效           | -         |
| error | SDK 发生错误时触发                   | error 对象 |


## 对象方法
<table>
<thead><tr><th>接口</th><th width=200px>参数</th><th>返回</th>
<th>　　　　说明　　　　</th></tr></thead>
<tbody><tr>
<td>async getOutput(fps)</td>
<td>- fps：设置输出的媒体流帧率，默认无须设置</td>
<td>MediaStream|String</td>
<td>仅 Web 端提供</td>
</tr>
<tr>
<td>setBeautify(options)</td>
<td>options：美颜参数对象</td>
<td>-</td>
<td>设置美颜参数，需开启美颜模块</td>
</tr>
<tr>
<td>setEffect(effects, callback)</td>
<td><ul style="margin:0">
   <li>effects：特效 ID | effect 对象 | 特效 ID / effect 数组
	<pre style="color: white;margin: 0px;overflow: scroll;display: block;width: 300px;">
effect:{
	id: string,
	intensity: number, // 默认1
	filterIntensity: number // 默认取intensity (0.1.18及以上版本支持)
}</pre>
	<li>callback：设置成功的回调</ul></td>
<td>-</td>
<td>设置特效，需开启美颜模块</td>
</tr>
<tr>
<td>setBackground(options)</td>
<td>options：{
	type: 'image|blur|transparent',
	src: string // 仅image类型需要
}</td>
<td>-</td>
<td>设置背景，需开启人像分割模块</td>
</tr>
<tr>
<td>setFilter(id, intensity, callback)</td>
<td>
   <li>id：滤镜 ID
   <li>intensity：滤镜强度，范围0-1
   <li>callback：设置成功回调</td>
<td>-</td>
<td>设置滤镜</td>
</tr>
<tr>
<td>getEffectList(params)</td>
<td><pre style="color:white;margin:0">
{
	PageNumber: number,
	PageSize: number,
	Name: '',
	Label: Array,
	Type: 'Custom|Preset'
}</pre>
</td>
<td>特效列表</td>
<td>拉取特效列表</td>
</tr>
<tr>
<td>getEffect(effectId)</td>
<td>effectId：特效 ID</td>
<td>单个特效信息</td>
<td>拉取指定特效的信息</td>
</tr>
<tr>
<td>getCommonFilter()</td>
<td>-</td>
<td>内置滤镜列表</td>
<td>获取内置滤镜列表</td>
</tr>
<tr>
<td>async updateInputStream(src:MediaStream) <br><b>（0.1.19版本后支持）</b></td>
<td>src：新的输入流MediaStream</td>
<td>-</td>
<td>更新输入流</td>
</tr>
<tr>
<td>disable()</td>
<td>-</td>
<td></td>
<td>停用面部检测，返回未处理的原始画面，可以降低CPU使用率</td>
</tr>
<tr>
<td>enable()</td>
<td>-</td>
<td></td>
<td>恢复面部检测，返回美颜等特效生效的画面</td>
</tr>
<tr>
<td>async startRecord()</td>
<td>-</td>
<td>-</td>
<td>开始录像（仅小程序端支持）</td>
</tr>
<tr>
<td>async stopRecord()</td>
<td>-</td>
<td>录像</td>
<td>结束录像并返回录像结果（仅小程序端支持）</td>
</tr>
<tr>
<td>async takePhoto()</td>
<td>-</td>
<td><pre style="color:white;margin:0">
{
	data: Uint8Array, 
	width: number, 
	height: number
}</pre>
</td>
<td>拍照，返回一个包含 buffer 数据的对象（仅小程序端支持）</td>
</tr>
</tbody></table>

## 错误处理
在 error 回调返回的对象中包含错误码与错误信息以方便进行错误处理。
```javascript
sdk.on('error', (error) => {
	// 在 error 回调中处理错误
	const {code, message} = error
	...
})
```

| 错误码  | 含义                | 备注  |
| ----- | ------------------- | --------- |
| 10000001 | 当前浏览器环境不兼容 | 建议用户使用 Chrome、Firefox、Safari、微信       |
| 10000005 | 输入源解析错误 | -       |
| 10001101 | 设置特效出错 | -         |
| 10001102 | 设置滤镜出错   | - |
| 10001201 | 调起用户摄像头失败   | - |
| 10001202 | 摄像头中断   | - |
| 20001001 | 鉴权失败   | 请确认是否创建 License，请确认签名是否正确 |
| 20001002 | 接口请求失败 | 回调会回传接口返回的数据，具体信息请参见 [接口错误码](https://cloud.tencent.com/document/product/616/71684) |
| 30000001 | 小程序 startRecord 失败 | - |
| 30000002 | 小程序 stopRecord 失败 | - |

## 延迟初始化 (0.1.18版本后开始支持)
默认情况下初始化 config 的 lazyInit 为 false；如果设置了 lazyInit 为 true，则 SDK 此时会先加载需要的资源文件，资源加载成功后会触发一个 resourceReady 事件，您可以在 resourceReady 事件触发后执行 `sdk.initCore` 完成初始化过程。
**延迟初始化的应用场景**：某些页面不一定立刻需要美颜 SDK，但您可以先执行资源加载，之后结合业务特性按需初始化 SDK 再展示效果。
下面是示例代码：
```javascript
// 获取鉴权参数
const authData = {
	licenseKey: 'xxxxxxxxx',
	appId: 'xxx',
	authFunc: authFunc // 详见「License 配置与使用 - 签名方法」
};
// 输入SDK的流
const stream = await navigator.mediaDevices.getUserMedia({
	audio: true,
	video: { width: 1280, height: 720 }
})

const config = {
	auth: authData, // 鉴权参数
    input: stream, // input传输入流
    lazyInit: true //开启延迟初始化
}
const sdk = new ArSdk(
	// 传入一个 config 对象用于初始化 sdk
	config
)
// sdk 延迟初始化的处理
sdk.on('resourceReady', async ()=>{
    console.log('resource ready')
    // 资源已加载完成，可以继续初始化过程，您也可以选择其他时机再执行initCore方法
    await sdk.initCore()
})

// sdk 的回调用法
sdk.on('created', () => {
    // 在 created 回调中拉取特效和滤镜列表供页面展示
    sdk.getEffectList({
        Type: 'Preset',
        Label: '美妆',
    }).then(res => {
        effectList = res
    });
    sdk.getCommonFilter().then(res => {
        filterList = res
    })
})
```

## 更新输入流（0.1.19版本后开始支持）

自定义流的场景，通常只需要在SDK初始化的时候指定 input 属性为输入流。若业务上需要切换输入流（例如有多个摄像头），请勿重新初始化SDK，可调用 SDK 的 updateInputStream 方法更新输入流，以避免重复的初始化造成的资源重复加载与延迟。
下述以切换电脑默认摄像头及外置摄像头为例，介绍 updateInputStream 的用法

```javascript

async function getVideoDeviceList(){
    const devices = await navigator.mediaDevices.enumerateDevices()
    const videoDevices = []
    devices.forEach((device)=>{
        if(device.kind === 'videoinput'){
            videoDevices.push({
                label: device.label,
                id: device.deviceId
            })
        }
    })
    return videoDevices
}

async function initDom(){
    const videoDeviceList = await getVideoDeviceList()
    let dom = ''
    videoDeviceList.forEach(device=>{
        dom = `${dom}
        <button id=${device.id} onclick='toggleVideo("${device.id}")'>${device.label}<nbutton>
        `
    })
    const div = document.createElement('div');
    div.id = 'container';
    div.innerHTML = dom;
    document.body.appendChild(div);
}

async function toggleVideo(deviceId){
    const stream = await navigator.mediaDevices.getUserMedia({
        video: {
            deviceId,
            width: 1280,
            height: 720,
          }
    })
	// 使用sdk提供的更新输入流接口，内部已处理旧轨道的 stop
	// 输入流更新后无需再次调用 getOutput ，SDK内部已处理
    sdk.updateInputStream(stream) 
}

initDom()

```