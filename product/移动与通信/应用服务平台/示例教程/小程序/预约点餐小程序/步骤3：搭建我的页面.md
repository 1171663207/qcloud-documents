本文主要围绕主页的 index 页面、[云开发内容管理](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/extensions/cms/introduction.html) 和 [云开发数据库](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database.html) 进行讲解，更多 index 代码细节可参见 [index 页面](https://github.com/ZiTao-Liu/Canteen-management-system/tree/main/miniprogram/pages/index)。



首先我们要获取到用户的openID我们这里采用云开发获取用户openid

> **该接口仅在小程序插件中可调用**，调用接口获得插件用户标志凭证（code）。插件可以此凭证换取用于识别用户的标识 openpid。用户不同、宿主小程序不同或插件不同的情况下，该标识均不相同，即当且仅当同一个用户在同一个宿主小程序中使用同一个插件时，openpid 才会相同。

openid作为小程序用户的唯一标识，就相当于用户在微信里的身份证一样，我们做小程序开发时，获取用户的openid是很重要的。通过云开发获取用户openid特别方便，并且可靠。

接下来我们了解一下云函数，编写获取用户openid：

> 云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。
>
> 小程序内提供了专门用于云函数调用的 API。开发者可以在云函数内使用 [`wx-server-sdk`](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/wx-server-sdk.html) 提供的 [`getWXContext`](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/utils/Cloud.getWXContext.html) 方法获取到每次调用的上下文（`appid`、`openid` 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（`openid`）。


## 操作步骤
### 步骤1：获取 openid

1. 创建云函数所需文件夹,由于我们之前创建项目时候采用的云开发说以我们在cloudfunctions侧击选择当前环境，然后新建Node.js云函数，创建名为open的云函数.

   <img src="./1.png" style="zoom:60%;" />

   

2. 在open云函数下，index.js文件下编写获取openid的代码

   > 云开发的云函数的独特优势在于与微信登录鉴权的无缝整合。当小程序端调用云函数时，云函数的传入参数中会被注入小程序端用户的 openid，开发者无需校验 openid 的正确性因为微信已经完成了这部分鉴权，开发者可以直接使用该 openid。
   >
   > 云开发的云函数的独特优势在于与微信登录鉴权的无缝整合。当小程序端调用云函数时，云函数的传入参数中会被注入小程序端用户的 openid，开发者无需校验 openid 的正确性，因为微信已经完成了这部分鉴权，开发者可以直接使用该 openid。与 openid 一起同时注入云函数的还有小程序的 appid。
   >
   > 从小程序端调用云函数时，开发者可以在云函数内使用 [`wx-server-sdk`](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/wx-server-sdk.html) 提供的 [`getWXContext`](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/utils/Cloud.getWXContext.html) 方法获取到每次调用的上下文（`appid`、`openid` 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（`openid`）。可以写这么一个云函数进行测试：

   ```javascript
   // 云函数入口文件
   const cloud = require('wx-server-sdk')
   
   cloud.init()
   
   // 云函数入口函数
   exports.main = async (event, context) => {
       const wxContext = cloud.getWXContext()
   
       return {
           event,
           openid: wxContext.OPENID,
           appid: wxContext.APPID,
           unionid: wxContext.UNIONID,
       }
   }
   ```

   我们在小程序页面调用云函数，会在调试器看到输出的res

3. 右键点击getOpenid，上传并部署云函数。

![](2.png)

4. 在app.js里初始化云开发

```js
// app.js
App({
  onLaunch: function () {
    if (!wx.cloud) {
      console.error('请使用 2.2.3 或以上的基础库以使用云能力');
    } else {
      wx.cloud.init({
        // env 参数说明：
        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源
        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看
        //   如不填则使用默认环境（第一个创建的环境）
         env: '环境ID',
        traceUser: true,
      });
    }

    this.globalData = {};
  },
  globalData:{
    userid:'' 
  }
});
```



5. 在我的页面编写代码

   这里我们使用Cloud.callFunction(object: Object): Promise<Object>调用云函数
   
   这里我们需要传递一下值
   
   | name | string |      | 是   | 云函数名                                              |
   | ---- | ------ | ---- | ---- | ----------------------------------------------------- |
   | data | Object |      | 否   | 传递给云函数的参数，在云函数中可通过 `event` 参数获取 |
   
   返回值
   
   | 属性   | 类型 | 说明             |
   | :----- | :--- | :--------------- |
   | result | any  | 云函数返回的结果 |
   
   > ```js
   > wx.cloud.callFunction({
   >   // 要调用的云函数名称
   >   name: '',
   >   // 传递给云函数的event参数
   >   data: {
   >     x: 1,
   >     y: 2,
   >   }
   > }).then(res => {
   >   // output: res.result === 3
   > }).catch(err => {
   >   // handle error
   > })
   > ```
   
   在这里我们写一个点击事件，在用户点击我们绑定getUserInfo事件的按钮之后，我们调用获取用户信息。getopenid是通过云函数获取用户openid方法。并将这个值存在app.js里面这样我们在其他页面可以直接进行调用。
   
   ```js
   const app = getApp();
   Page({
       /**
        * 页面的初始数据
        */
       data: {
           username:"",
           openid: '',
       },
       /**
        * 生命周期函数--监听页面加载
        */
       onLoad: function (options) {
        
       },
       getUserInfo(e){
           console.log(e);
           this.setData({
             username:e.detail.userInfo.nickName 
         })
         },
         getopenid(){
           var that=this;
           wx.cloud.callFunction({
             name: 'open',
             success:(res)=> {
               var usid = res.result.openid
               console.log(usid)
               this.setData({
                 openid:res.result.openid,
               })
               getApp().globalData. userid=res.result.openid
             },
             fail(res) {
               console.log("获取失败", res);
             }
           })
         },
      })
   ```
   
   在页面中我们可以进行判断如果没有获取到提醒用户登录，这里我们进行判断，如果获取到的openid为空我们显示授权登录板块。
   
   ```xml
   <view class="topbanner"  wx:if="{{openid!=''}}"> 
       <view class="toplogo">
           <open-data type="userAvatarUrl"></open-data>
       </view>
       <view class="toptext">
       <open-data type="userNickName" lang="zh_CN" class="user-name"></open-data>  
       <view class="user-name2">爱国、敬业、求实、创新</view>
       </view>
   </view>
   <view class="topbanner" wx:if="{{openid==''}}"> 
       <view class="topban1">您还未授权登录</view>
       <view class="topban1">去授权登录</view>
       <button bindtap="getopenid" type="default">登录</button>
   </view>
   ```
   
   其他细节开发在视频中体现哦！
   
   这里我们可以思考一下，现在我们是不是每次用户进入小程序都需要用户授权登录一次呢，这样是不是不是很方便，我们可以将它存在 wx.setStorageSync，直接调用。
   
   > 将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB
   
   ![](17.jpg)
   
### 步骤2：获取用户信息
   
   但我们要注意微信在2月21日之后open-data将无法展示用户个人信息，这里我们提供两种解决方案获取用户的信息：
   
   <img src="0.jpg" style="zoom:50%;" />
   
   ##### 第一种使用 getUserProfile
   
   我们可以查看一下官方文档 wx.getUserProfile(Object object)，获取用户信息。页面产生点击事件（例如 button 上 bindtap 的回调中）后才可调用，每次请求都会弹出授权窗口，用户同意后返回 userInfo。但要注意每次都需要授权一次是不是很麻烦，我们可以将他保存在我们数据库中授权一次日后直接调用。
   
   ###### 代码示例
   
   ```xml
   <view class="container">
     <view class="userinfo">
       <block wx:if="{{!hasUserInfo}}">
         <button wx:if="{{canIUseGetUserProfile}}" bindtap="getUserProfile"> 获取头像昵称 </button>
         <button wx:else open-type="getUserInfo" bindgetuserinfo="getUserInfo"> 获取头像昵称 </button>
       </block>
       <block wx:else>
         <image bindtap="bindViewTap" class="userinfo-avatar" src="{{userInfo.avatarUrl}}" mode="cover"></image>
         <text class="userinfo-nickname">{{userInfo.nickName}}</text>
       </block>
     </view>
   </view>
   ```
   
   ```js
   Page({
     data: {
       userInfo: {},
       hasUserInfo: false,
       canIUseGetUserProfile: false,
     },
     onLoad() {
       if (wx.getUserProfile) {
         this.setData({
           canIUseGetUserProfile: true
         })
       }
     },
     getUserProfile(e) {
       wx.getUserProfile({
         desc: '用于完善会员资料', // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写
         success: (res) => {
           this.setData({
             userInfo: res.userInfo,
             hasUserInfo: true
           })
         }
       })
     },
   ```
   
   #### 第二种使用 头像昵称填写
   
   当小程序需要让用户完善个人资料时，可以通过微信提供的头像昵称填写能力快速完善。
   
    **头像选择**
   
   需要将 button 组件 open-type 的值设置为 chooseAvatar，当用户选择需要使用的头像之后，可以通过 bindchooseavatar 事件回调获取到获取到头像信息的临时路径。
   
   **昵称填写**
   
   需要将 input 组件 type 的值设置为 nickname，当用户在此input进行输入时，键盘上方会展示微信昵称。
   
     然后我们将他存到数据库，日后直接调用即可！
   
   接下来我们开发攻略页面
   
   ```xml
   <button class="avatar-wrapper" open-type="chooseAvatar" bind:chooseavatar="onChooseAvatar">
     <image class="avatar" src="{{avatarUrl}}"></image>
   </button> 
   <input type="nickname" class="weui-input" placeholder="请输入昵称"/>
   ```
   
   ```js
   const defaultAvatarUrl = 'https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0'
   Page({
     data: {
       avatarUrl: defaultAvatarUrl,
     },
     onChooseAvatar(e) {
       const { avatarUrl } = e.detail 
       this.setData({
         avatarUrl,
       })
     }
   })
   ```
   
   ![](51.jpg)
   
   接下来我们要将值进行存储，并上传数据库。我们使用form将数据保存到data里面。
   
   ```xml
   <button class="avatar-wrapper" open-type="chooseAvatar" bind:chooseavatar="onChooseAvatar">
     <image class="avatar" src="{{avatarUrl}}"></image>
   </button>
   <form catchsubmit="formSubmit">
     <view class="row">
       <view class="text1">名称：</view>
       <input type="nickname" class="weui-input" name="input" placeholder="请输入昵称" />
     </view>
     <button type="primary" style="margin-top:40rpx;margin-bottom:20rpx" formType="submit">提交</button>
   </form>
   ```
   
   ```js
   const defaultAvatarUrl = 'https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0'
   Page({
     /**
      * 页面的初始数据
      */
     data: {
       avatarUrl: defaultAvatarUrl,
       name: '',
     },
     onChooseAvatar(e) {
       const { avatarUrl } = e.detail
       this.setData({
         avatarUrl,
       })
     },
     formSubmit(e) {
       console.log(e.detail.value.input)
       this.setData({
         name: e.detail.value.input
       })
      }
    })
   ```
   
   这样我们点击提交时候发现值保存data里面了，接下来我们获取openid,可以参考之前视频哦！这里默认已经将openid保存到app.js里面了！
   
   ```js
   onLoad: function (options) {
       const app = getApp()
       var userid = app.globalData.openid
       this.setData({
         userid: userid,
       })
     },
   ```
   
   接下来我们上传图片到云开发，然后存到数据库中，这里在cms创建内容模型。
   
   ![](48.jpg)
   
   这里我们使用到wx.cloud.uploadFile，将本地资源上传至云存储空间
   
   > 如果上传至同一路径则是覆盖写
   >
   > | 字段      | 说明                                                         | 数据类型 | 默认值 | 必填 |
   > | :-------- | :----------------------------------------------------------- | :------- | :----- | :--- |
   > | cloudPath | 云存储路径，命名限制见[文件名命名限制](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/storage/naming.html) | String   | -      | Y    |
   > | filePath  | 要上传文件资源的路径                                         | String   | -      | Y    |
   > | config    | 配置                                                         | Object   | -      | N    |
   > | success   | 成功回调                                                     |          |        |      |
   > | fail      | 失败回调                                                     |          |        |      |
   > | complete  | 结束回调                                                     |          |        |      |
   >
   > success 返回参数
   >
   > | 字段       | 说明                         | 数据类型 |
   > | :--------- | :--------------------------- | :------- |
   > | fileID     | 文件 ID                      | String   |
   > | statusCode | 服务器返回的 HTTP 状态码     | Number   |
   > | errMsg     | 错误信息，格式 uploadFile:ok | String   |
   
   ```js
   // pages/getuser/getuser.js
   const db = wx.cloud.database()
   const defaultAvatarUrl = 'https://mmbiz.qpic.cn/mmbiz/icTdbqWNOwNRna42FI242Lcia07jQodd2FJGIYQfG0LAJGFxM4FbnQP6yfMxBgJ0F3YRqJCJ1aPAK2dQagdusBZg/0'
   Page({
     /**
      * 页面的初始数据
      */
     data: {
       avatarUrl: defaultAvatarUrl,
       name: '',
       userid: '',
       userphoto: '',
       imgrl: ''
     },
     onChooseAvatar(e) {
       const { avatarUrl } = e.detail
       this.setData({
         avatarUrl,
       })
     },
     formSubmit(e) {
       console.log(e.detail.value.input)
       this.setData({
         name: e.detail.value.input
       })
       var that = this;
           wx.cloud.uploadFile({
             cloudPath: (new Date()).valueOf() + '.png', // 文件名
             filePath: this.data.avatarUrl, // 文件路径
             success: res => {
               // get resource ID
               console.log(res.fileID)
               // 赋值图片
               that.setData({
                 imgrl: res.fileID
               })
               that.upload(res.fileID);
             },
             fail: err => {
               // handle error
             }
           })
     },
     upload(filepath){
       console.log(filepath)
       db.collection("user").add({
         data: {
             name:this.data.name,
             openid:this.data.userid,
             userphoto:filepath,
             _createTime: Date.parse(new Date()),
         }
     }).then(res => {
         wx.showToast({
             title: '添加成功',
             icon: 'success',
             duration: 2000
         })
     })
     },
     /** 
      * 生命周期函数--监听页面加载
      */
     onLoad: function (options) {
       const app = getApp()
       var userid = app.globalData.openid
       this.setData({
         userid: userid,
       })
     },
   })
   ```
   
   这样我们就完成了！
   
   ![](c5.png)
   
   ### 攻略评论

​		评论攻略我们可以思考我们创建一个用户可以发布，评论的一个平台，我们创建模型以及开发可以参考视频里面的讲解。

![](25.jpg)

这里我们依然通过wx:for渲染出列表，并给他点击跳转事件，并将当前文章id编号进行传递。

```xml
<!--pages/gltl/gltl.wxml-->
<view class="banner">
    <!----><image src="https://6363-ccntst-8gsp6zkw250f8e38-1305928500.tcb.qcloud.la/cloudbase-cms/upload/2021-11-25/5hbujycykft9vg9g82xcsw0f6z34v8o5_.jpg"></image>
</view> 
<view class="miin_baer">
    <view class="title_pl">
     <view class="pl_bt">攻略评论</view> 
     <view class="qpl" id="{{rmbs._id}}" bindtap='showtl'>发表</view>
     </view>
    <view class="mian_box"  wx:for="{{rmbs}}" wx:for-item="item" wx:key="_id"  bindtap='showbs' id="{{item._id}}">
        <view class="min_box_img">
            <image src="{{item.phpto}}"></image>
        </view>
        <view class="mian_text">
            <view class="miam_text_title">
                {{item.title}}
            </view>
            <view class="mian_user">
                <view class="user_logo">
                    <image src="../../images/font-ui/nstx.png"></image>
                </view>
                <view class="user_name">
                    {{item.user}}
                </view>
                <view class="taolun">
                    <image src="../../images/font-ui/pinglun-08.png"></image>
                </view>
                <view class="liulanl">
                    <view class="lll_zp"> 
                        <image src="../../images/font-ui/liulan.png"></image>
                    </view>
                    <view class="lll_sz">
                        {{item.lll}}+
                    </view>
                </view>
            </view>
        </view>
    </view>
</view>
```

```js
// pages/gltl/gltl.js
wx.cloud.init({
    env: 'ccntst-8gsp6zkw250f8e38',
    traceUser: true,
  })
  const db=wx.cloud.database()
Page({

    /**
     * 页面的初始数据
     */
    data: {
        rmbs:''
    },

    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
        db.collection("glpj").get().then(res=>{
            console.log(res)
            this.setData({
              rmbs:res.data
            })
             })
    },
    showbs:function(e){
        console.log(e.currentTarget.id)
        wx.navigateTo({
          url:'/pages/glxq/glxq?list_id='+e.currentTarget.id,
      })
    },
    showtl:function(e){
      wx.navigateTo({
        url:'/pages/fbpl/fbpl',
    })
    },
 })   
```

这样攻略评论的首页面我们就开发完毕了。

接下来开发攻略详情发布攻略的页面。

我们在内容模型创建攻略评论模型。

<img src="0045.jpg" style="zoom:50%;" />

这里我们获取到来刚才传过来的listid,在数据库之中查询这条数据。

在这里我们要思考，是不是需要用户浏览一次数据就自增+1，这里我那使用到 Command.inc(value: number): Command

> 更新操作符，原子操作，用于指示字段自增
>
> 参数  value: number  自增量，可正可负
>
> ###### 示例代码
>
> 将一个 todo 的进度自增 10：
>
> ```js
> const _ = db.command
> db.collection('todos').doc('todo-id').update({
>   data: {
>     progress: _.inc(10)
>   }
> })
> ```

```js
// pages/glxq/glxq.js
wx.cloud.init({
    env: 'ccntst-8gsp6zkw250f8e38',
    traceUser: true,
  })
  const db=wx.cloud.database()
Page({

    /**
     * 页面的初始数据
     */
    data: {
        list_id:"",
        rmb:""
    },

    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
        this.setData({
            list_id:options.list_id
          })
          console.log( this.data.list_id),
           /**/
           db.collection("glpj").doc(this.data.list_id).get().then(res=>{
            console.log(res)
            this.setData({
              rmbs:res.data
            })
        })
        const _=db.command
        db.collection('glpj').doc(this.data.list_id).update({
            data:{
                lll:_.inc(1)
            }   
        })
        db.collection("glplgl").where({plwz:this.data.list_id}).get().then(res=>{
          console.log(res)
          this.setData({
            rmb:res.data
          })
      })
    },

    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady: function () {

    },

    /**
     * 生命周期函数--监听页面显示
     */
    onShow: function () {

    },
    showbs:function(e){
      console.log(e.currentTarget.id)
      wx.navigateTo({
        url:'/pages/xpl/xpl?list_id='+e.currentTarget.id,
    })
  },    
})
```

```xml
<!--pages/glxq/glxq.wxml-->
<view class="zpq" id="{{item._id}}">
    <image src="{{rmbs.phpto}}"></image>
</view>
<view class="dd">
    <rich-text class="rich" nodes="{{rmbs.xq}}"></rich-text>
</view>
<view class="fbsj">
    发布时间：{{rmbs.time}}
</view>
<view class="lll">
    <view class="liulanl">
        <view class="lll_zp">
            <image src="../../images/font-ui/liulan.png"></image>
        </view>
        <view class="lll_sz">
            {{rmbs.lll}}+
        </view>
    </view>
</view>
<view class="pl">
    <view class="title_pl">
     <view class="pl_bt">评论</view> 
     <view class="qpl" id="{{rmbs._id}}" bindtap='showbs'>去评论</view>
     </view>
    <view class="pl_box" wx:for="{{rmb}}" wx:for-item="item" wx:key="_id"  >
        <view class="pl_xxl" >
            <view class="pl_tx">
                <image src="../../images/font-ui/nstx.png"></image>
            </view>
            <view class="pl_xx_us">
                <view class="pl_xx_user">
                    {{item.username}}
                </view>
                <view class="pl_xx_time">
                    {{item.data}}
                </view>
            </view>
            <view class="dz">
                <image src="../../images/font-ui/dzz.png"></image>
            </view>
        </view>
        <view class="plxx_xq">
            {{item.text}}
        </view>
    </view>
</view>
```

发布评论的时候我们需要获取到用户的openid和当前要发布评论的文章id.

```js
// pages/xpl/xpl.js
wx.cloud.init({
    env: 'ccntst-8gsp6zkw250f8e38',
    traceUser: true,
})
const db = wx.cloud.database()
var myDate = new Date();
Page({

    /**
     * 页面的初始数据
     */
    data: {
        list_id: "",
        userid: '',
    },

    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
        this.setData({
            list_id: options.list_id
        })
        console.log(this.data.list_id)
        const app = getApp()
        var userid = app.globalData.userid
        this.setData({
            userid: userid,
        })
    },
    showsq: function () {
        wx.switchTab({
            url: '../my/my',
        })
    },
    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady: function () {

    },
    btnSub(res) {

        if (res.detail.value.text != '' && res.detail.value.username != '') {
            var {
                text,
                username
            } = res.detail.value;
            db.collection("glplgl").add({
                data: {
                    user: this.data.userid,
                    text: text,
                    plwz: this.data.list_id,
                    username: username,
                    data: myDate.toLocaleString(),
                    _createTime: Date.parse(new Date()),
                }
            }).then(res => {
                wx.showToast({
                    title: '成功',
                    icon: 'success',
                    duration: 2000
                })
            })
        } else {
            wx.showToast({
                title: '请填写信息',
                icon: 'error',
                duration: 2000
            })
        }
    },
})
```

```xml
<!--pages/xpl/xpl.wxml-->
<view class="banner">
    <!----><image src="https://6363-ccntst-8gsp6zkw250f8e38-1305928500.tcb.qcloud.la/cloudbase-cms/upload/2021-11-25/5hbujycykft9vg9g82xcsw0f6z34v8o5_.jpg"></image>
</view> 
<view class="wdl_ban" wx:if="{{userid==''}}">
    <view class="wdl">
        <image src="../../images/font-ui/wdl.png"></image>
    </view>
    <view class="text_main">您还未授权登录，请授权登录！</view>
    <button size="mini" type="primary" bindtap='showsq' class="btn_sq">去授权</button>
</view>
<view class="xpl" wx:if="{{userid!=''}}">
    <form bindsubmit="btnSub">
        <view class="top-s">
            <view class="top-text">用户名称：</view>
            <view class="weui-cell__bd">
              <input class="weui-input" name="username" placeholder="输入名称" />
            </view>
        </view>
        <view class="top-s">
            <view class="top-text">评论：</view>
            <view class="weui-cell__bd">
                <textarea bindblur="bindTextAreaBlur" name="text" class="weui-text" auto-height placeholder="自动变高" />
            </view>
        </view>
        <button style="margin: 0 aout;margin-top:40rpx;margin-bottom:40rpx;" type="primary" formType="submit">发表评论</button>
    </form>
</view>
```

我们引入内容安全，微信云开发提供内容安全功能，可对云开发数据库中存储的信息进行内容安全的规则设置，自动进行内容审核并对触发违规的内容进行处理。

> 为保证微信生态的内容安全，在小程序提审时，审核人员将会对该小程序中是否会展示违规内容进行审核，若有违规则可能造成小程序提审不通过。另外在小程序线上运营过程中，若由于展示违规内容造成了用户举报，也会对小程序进行处罚操作。 为减少上述情况的发生，微信云开发提供内容安全功能，可对云开发数据库中存储的信息进行内容安全的规则设置，自动进行内容审核并对触发违规的内容进行处理。

使用方法：

1. 开通内容安全

   进入云开发控制台，点击“更多”-“内容安全”，即可点击开通

2.  创建规则

​		点击“添加”按钮，在下拉框中选择所要应用内容安全规则的集合名称，配置字段key值，填写触发违规后的重写内容，若该字段经审核触发违规后，将会被自动改写为该内容。

<img src="3.png" style="zoom:60%;" />
