**注意事项**
- 云数据库 SqlServer 2014以下版本不支持 MemoryTable，若有 MemoryTable 类的需求建议使用云数据库 Redis 、Memcached。
- 新建表建议遵循数据库三范式，每张表建议要有主键，即使选不出合适的列做主键，也要添加一个列做主键。 
- 字段尽量定义为 NOT NULL 并加上默认值，NULL 会给 SQL 开发带来很多问题导致走不了索引，对 NULL 计算时只能用 IS NULL 和 IS NOT NULL 来判断。
​
**建议事项**
- 通过业务场景分析和数据访问（包括数据库读写 QPS、 TPS、存储空间等）的预估，合理规划数据库使用资源，也可以在控制台云监控界面，配置云数据库 SQL Server 实例的各项监控。
- 建库原则就是同一类业务的表放一个库，不同业务的表尽量避免公用同一个库，尽量避免在程序中执行跨库的关联操作，此操作对后续的快速回档也会产生一定的影响。
- 字符集建议统一使用一个字符集，避免不同字符集之间数据乱码。
- 小数字段推荐使用 decimal 类型，float 和 double 精度不够，特别是涉及金钱的业务。 
- 尽量避免数据库中使用 text/blob 来存储大段文本、二进制数据、图片、文件等内容，而是将这些数据保存成本地磁盘文件，数据库中只保存其索引信息。
- 尽量不使用外键，建议在应用层实现外键的逻辑，外键与级联更新不适合高并发场景，降低插入性能，大并发下容易产生死锁。
- 降低业务逻辑和数据存储的耦合度，数据库存储数据为主，业务逻辑尽量通过应用层实现，尽可能减少对实例级别的触发器、linkserver、job 等高级功能的使用，这些功能移植性、可扩展性较差，若实例中存在此类对象，迁移之后需要手动再将这些对象迁移到新的实例。
- 短期内业务达不到一个比较大的量级，建议避免使用分区表。分区表主要用作归档管理，在业务中大部分的查询不走分区字段的情况下，分区表对性能提升作用不大。
- 对读压力较大，且一致性要求较低（接受数据秒级延时）的业务场景，建议购买只读实例来实现读写分离策略。
​
### 索引设计规范
**注意事项**
- 建议不要在更新十分频繁、区分度不高的列上建立索引，记录更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。
- 建复合索引时，区分度最高的列放索引的最左边，例如 select xxx where a = x and b = x;，a 和 b 一起建组合索引，a 的区分度更高，则建 idx_ab(a,b)。业务存在大量非等号和等号混合判断条件场景时，建议把等号条件的列前置，例如，where a xxx and b = xxx那么即使 a 的区分度更高，也建议把 b 放在索引的最前列，因为走不到索引 a。
​
**建议事项**
- 单表的索引数建议不超过5个，单个索引中的字段数建议不超过5个，太多起不到过滤作用，索引也占空间，管理起来也耗资源。
- 选择业务中 SQL 过滤走的最多的并且重复值比较少的列建索引，业务 SQL 不走的列建索引是无意义的，字段的唯一性越高索引过滤效果也越好。 
- 避免冗余索引，两个索引 (a,b) (a) 同时存在，则 (a) 属于冗余索引 redundant index，若查询过滤条件为 a 列，(a,b) 索引就够了，不用单独建 (a) 索引。
- 合理利用 Include 索引来降低 IO 开销，常用的列放在前面，不会作为查询条件的列可以放在 Include 中。
​
### SQL 编写规范
**注意事项**
- UPDATE、DELETE 建议使用 WHERE 精准匹配，需要删除大量数据建议分批处理并在业务低峰期进行。
- 使用 INSERT INTO t_xxx VALUES(xxx)，建议显式指定插入的列属性，避免表结构变动导致数据出错。
- SQL 语句中最常见的导致索引失效的情况需注意：
 - 隐式类型转换，如索引 a 的类型是 varchar，SQL 语句写成 where a = 1; varchar 变成了 int。
 - 对索引列进行数学计算和函数等操作，例如，使用函数对日期列进行格式化处理。
 - 多列排序顺序不一致问题，如索引是 (a,b)，SQL 语句是 order by a b desc。
 - 尽量使 where 条件完全匹配避免条件的模糊匹配和 in，not in 批量匹配。
​
**建议事项**
按需索取，拒绝select *，规避以下问题：
- 无法索引覆盖，回表操作，增加 I/O。
- 额外的内存负担，大量冷数据灌入缓存，降低查询命中率。
- 额外的网络传输开销。
- 尽量避免使用大事务，建议大事务拆小事务，规避大事物造成实例阻塞或主从延迟。
- 业务代码中事务及时提交，避免产生没必要的锁等待。
- 尽量减少用多表 join，大表 join。两张表 join 尽量让小表做驱动表，建议 join 列类型一致且都建有索引。
​
**说明**
- 上述情况很难完全避免，推荐方案是不要将此类条件作为主要过滤条件，跟在走索引的主要过滤条件之后则问题不大。
- 若您在监控上发现全表扫描的量比较大，可以在控制台下载慢日志文件分析。
- 业务上线之前做有必要的 SQL 审核，日常运维需定期下载慢查询日志做针对性优化。
​
